<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0; background: #0f172a; color: white;
            font-family: 'Inter', sans-serif; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; overflow: hidden; outline: none; touch-action: none;
        }
        .header-info {
            display: flex; justify-content: space-between; width: 400px;
            max-width: 90vw; margin-bottom: 10px; font-weight: bold; font-size: 0.9rem;
        }
        .canvas-wrapper {
            border: 3px solid #00d2ff; border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.2);
            line-height: 0; position: relative; background: #020617;
        }
        canvas { max-width: 90vw; max-height: 55vh; }
        .lvl-text { color: #00d2ff; }
        .win-msg { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #10b981; font-weight: bold; font-size: 2rem; display: none; 
            text-shadow: 0 0 20px #10b981; z-index: 20; background: rgba(15,23,42,0.95);
            padding: 25px; border-radius: 20px; border: 2px solid #10b981; text-align: center;
        }
        .controls-container {
            display: none; margin-top: 20px;
            grid-template-columns: repeat(3, 65px);
            grid-template-rows: repeat(2, 65px); gap: 12px;
        }
        .btn {
            width: 65px; height: 65px; background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(0, 210, 255, 0.3); border-radius: 18px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: white; transition: 0.1s;
        }
        .btn:active { background: rgba(0, 210, 255, 0.4); transform: scale(0.9); }
        .up { grid-column: 2; } .left { grid-column: 1; grid-row: 2; }
        .down { grid-column: 2; grid-row: 2; } .right { grid-column: 3; grid-row: 2; }
        @media (pointer: coarse) { .controls-container { display: grid; } }
    </style>
</head>
<body tabindex="0">
    <div class="header-info">
        <span>УРОВЕНЬ: <span id="level-val" class="lvl-text">1</span></span>
        <span>ОБЗОР: <span id="vision-val" class="lvl-text">MAX</span></span>
    </div>
    <div id="win" class="win-msg">ПУТЬ НАЙДЕН!<br><span style="font-size: 1rem; opacity: 0.8;">Загрузка следующего...</span></div>
    
    <div class="canvas-wrapper">
        <canvas id="maze"></canvas>
    </div>

    <div class="controls-container">
        <div class="btn up" id="btn-ArrowUp">▲</div>
        <div class="btn left" id="btn-ArrowLeft">◀</div>
        <div class="btn down" id="btn-ArrowDown">▼</div>
        <div class="btn right" id="btn-ArrowRight">▶</div>
    </div>

    <script>
        const canvas = document.getElementById('maze');
        const ctx = canvas.getContext('2d');
        const winMsg = document.getElementById('win');
        const levelDisplay = document.getElementById('level-val');
        const visionDisplay = document.getElementById('vision-val');

        let level = 1;
        let cellSize, cols, rows, grid, player;

        function initGame() {
            // Клетки мельчают медленнее для комфорта
            cellSize = Math.max(14, 40 - (Math.floor(level/2) * 4)); 
            
            cols = Math.floor(400 / cellSize);
            rows = Math.floor(400 / cellSize);
            if (cols % 2 === 0) cols--;
            if (rows % 2 === 0) rows--;

            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            grid = Array(rows).fill().map(() => Array(cols).fill(1));
            generate(0, 0);
            
            grid[rows-1][cols-1] = 0;
            if(rows > 1 && cols > 1) {
                grid[rows-1][cols-2] = 0;
                grid[rows-2][cols-1] = 0;
            }

            player = {x: 0, y: 0};
            winMsg.style.display = 'none';
            levelDisplay.innerText = level;
            
            visionDisplay.innerText = level < 5 ? "Wide" : (level < 10 ? "Medium" : "Narrow");
            draw();
        }

        function generate(x, y) {
            grid[y][x] = 0;
            const dirs = [[0,2],[0,-2],[2,0],[-2,0]].sort(() => Math.random() - 0.5);
            for (let [dx, dy] of dirs) {
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && grid[ny][nx] === 1) {
                    grid[y + dy/2][x + dx/2] = 0;
                    generate(nx, ny);
                }
            }
        }

        const keys = {};
        window.addEventListener('keydown', e => { keys[e.key] = true; });
        window.addEventListener('keyup', e => { keys[e.key] = false; });

        const setupMobileBtn = (id, keyName) => {
            const btn = document.getElementById(id);
            const action = (e, val) => { e.preventDefault(); keys[keyName] = val; };
            btn.addEventListener('touchstart', (e) => action(e, true));
            btn.addEventListener('touchend', (e) => action(e, false));
            btn.addEventListener('mousedown', (e) => action(e, true));
            btn.addEventListener('mouseup', (e) => action(e, false));
        };
        setupMobileBtn('btn-ArrowUp', 'ArrowUp');
        setupMobileBtn('btn-ArrowDown', 'ArrowDown');
        setupMobileBtn('btn-ArrowLeft', 'ArrowLeft');
        setupMobileBtn('btn-ArrowRight', 'ArrowRight');

        let lastMove = 0;
        function update(timestamp) {
            const moveDelay = Math.max(70, 130 - level * 5); 

            if (timestamp - lastMove > moveDelay) {
                let nx = player.x, ny = player.y;
                if (keys['ArrowUp']) ny--;
                else if (keys['ArrowDown']) ny++;
                else if (keys['ArrowLeft']) nx--;
                else if (keys['ArrowRight']) nx++;

                if (nx !== player.x || ny !== player.y) {
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && grid[ny][nx] === 0) {
                        player.x = nx; player.y = ny;
                        lastMove = timestamp;
                        if (player.x === cols-1 && player.y === rows-1) {
                            winMsg.style.display = 'block';
                            level++;
                            setTimeout(initGame, 1500);
                        }
                    }
                }
            }
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            // 1. Рисуем лабиринт
            ctx.fillStyle = '#0f172a'; // Проход
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#334155'; // Стены
            for(let y = 0; y < rows; y++) {
                for(let x = 0; x < cols; x++) {
                    if(grid[y][x] === 1) {
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // 2. Рисуем выход
            ctx.fillStyle = '#10b981';
            ctx.fillRect((cols-1)*cellSize + cellSize*0.2, (rows-1)*cellSize + cellSize*0.2, cellSize*0.6, cellSize*0.6);

            // 3. Рисуем игрока
            const px = player.x * cellSize + cellSize/2;
            const py = player.y * cellSize + cellSize/2;
            
            ctx.fillStyle = '#00d2ff';
            ctx.shadowBlur = 15; ctx.shadowColor = '#00d2ff';
            ctx.beginPath();
            ctx.arc(px, py, cellSize/3, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // 4. НАКЛАДЫВАЕМ ЭФФЕКТ СВЕТА (Vignette)
            // Радиус обзора: от 6 ячеек на старте до 3 на высоких уровнях
            const viewRadius = Math.max(cellSize * 3, cellSize * (7 - level * 0.3));
            
            const gradient = ctx.createRadialGradient(px, py, cellSize/2, px, py, viewRadius);
            gradient.addColorStop(0, 'rgba(0,0,0,0)'); // Прозрачно в центре
            gradient.addColorStop(0.7, 'rgba(2, 6, 23, 0.4)'); // Легкая тень
            gradient.addColorStop(1, 'rgba(2, 6, 23, 1)'); // Полная темнота в конце радиуса

            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Дополнительный слой абсолютной темноты за пределами радиуса
            // (чтобы градиент не повторялся)
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.arc(px, py, viewRadius, 0, Math.PI*2, true);
            ctx.fillStyle = 'rgba(2, 6, 23, 1)';
            ctx.fill();
        }

        initGame();
        requestAnimationFrame(update);
    </script>
</body>
</html>